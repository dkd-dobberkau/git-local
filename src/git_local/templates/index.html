{% extends "base.html" %}

{% block content %}
<header class="header">
  <div class="header-left">
    <button class="header-icon" onclick="toggleLang()" title="Sprache / Language">
      <span id="lang-label">DE</span>
    </button>
  </div>
  <div class="header-title">{{ title }}</div>
  <div class="header-actions">
    <button class="header-icon" onclick="toggleDarkMode()" id="dark-mode-btn" title="Dark Mode">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
      </svg>
    </button>
    <button
      class="header-icon"
      hx-get="/partials/repos"
      hx-target="#repo-list"
      hx-swap="innerHTML"
      data-i18n-title="refresh"
    >
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
        <path d="M21 3v5h-5"/>
      </svg>
    </button>
  </div>
</header>

<main class="main">
  <div class="filter-bar">
    <input
      type="text"
      class="filter-input"
      id="filter-input"
      data-i18n-placeholder="filter"
      oninput="filterRepos(this.value)"
    >
    <div class="sort-buttons">
      <button class="sort-btn" onclick="sortRepos('date')" data-i18n="date">Datum</button>
      <button class="sort-btn active" onclick="sortRepos('name')" data-i18n="az">A-Z</button>
      <button class="sort-btn" onclick="sortRepos('remote')" data-i18n="remote">Remote</button>
    </div>
    <span class="repo-count"><span id="visible-count">{{ repo_count }}</span> / {{ repo_count }} <span data-i18n="repositories">Repositories</span></span>
  </div>

  <div id="repo-list">
    {% include "components/repo_list.html" %}
  </div>
</main>

<script>
// Translations
const i18n = {
  de: {
    filter: 'Filter...',
    date: 'Datum',
    az: 'A-Z',
    remote: 'Remote',
    repositories: 'Repositories',
    refresh: 'Aktualisieren',
    clean: 'clean',
    uncommitted: 'uncommitted',
    branch: 'Branch',
    branches: 'Branches',
    openFinder: 'Im Finder öffnen',
    openVscode: 'In VS Code öffnen',
    openTerminal: 'Terminal öffnen'
  },
  en: {
    filter: 'Filter...',
    date: 'Date',
    az: 'A-Z',
    remote: 'Remote',
    repositories: 'Repositories',
    refresh: 'Refresh',
    clean: 'clean',
    uncommitted: 'uncommitted',
    branch: 'Branch',
    branches: 'Branches',
    openFinder: 'Open in Finder',
    openVscode: 'Open in VS Code',
    openTerminal: 'Open Terminal'
  }
};

let currentLang = localStorage.getItem('lang') || 'de';

function applyTranslations() {
  const t = i18n[currentLang];

  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.dataset.i18n;
    if (t[key]) el.textContent = t[key];
  });

  document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
    const key = el.dataset.i18nPlaceholder;
    if (t[key]) el.placeholder = t[key];
  });

  document.querySelectorAll('[data-i18n-title]').forEach(el => {
    const key = el.dataset.i18nTitle;
    if (t[key]) el.title = t[key];
  });

  document.getElementById('lang-label').textContent = currentLang.toUpperCase();
}

function toggleLang() {
  currentLang = currentLang === 'de' ? 'en' : 'de';
  localStorage.setItem('lang', currentLang);
  applyTranslations();
}

// Dark Mode
function initDarkMode() {
  const saved = localStorage.getItem('darkMode');
  if (saved === 'true') {
    document.body.classList.add('dark');
  } else if (saved === 'false') {
    document.body.classList.remove('dark');
  }
  // If no saved preference, use system preference (handled by CSS)
}

function toggleDarkMode() {
  document.body.classList.toggle('dark');
  localStorage.setItem('darkMode', document.body.classList.contains('dark'));
}

// Filter
function filterRepos(query) {
  const items = document.querySelectorAll('.repo-item');
  const q = query.toLowerCase();
  let visible = 0;

  items.forEach(item => {
    const name = item.querySelector('.repo-item-name').textContent.toLowerCase();
    const badges = item.querySelectorAll('.badge');
    let badgeMatch = false;
    badges.forEach(b => {
      if (b.textContent.toLowerCase().includes(q)) badgeMatch = true;
    });

    if (name.includes(q) || badgeMatch) {
      item.style.display = '';
      visible++;
    } else {
      item.style.display = 'none';
    }
  });

  document.getElementById('visible-count').textContent = visible;
}

// Sort
function sortRepos(by) {
  const list = document.querySelector('.repo-list');
  const items = Array.from(list.querySelectorAll('.repo-item'));

  document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
  event.target.classList.add('active');

  items.sort((a, b) => {
    if (by === 'name') {
      return a.dataset.name.localeCompare(b.dataset.name);
    } else if (by === 'date') {
      return parseFloat(b.dataset.date) - parseFloat(a.dataset.date);
    } else if (by === 'remote') {
      const remoteA = a.dataset.remote || 'zzz';
      const remoteB = b.dataset.remote || 'zzz';
      return remoteA.localeCompare(remoteB);
    }
  });

  items.forEach(item => list.appendChild(item));
}

// Init
initDarkMode();
applyTranslations();
</script>
{% endblock %}
